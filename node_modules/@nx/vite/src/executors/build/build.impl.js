"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    viteBuildExecutor: function() {
        return viteBuildExecutor;
    },
    default: function() {
        return _default;
    }
});
const _extends = require("@swc/helpers/_/_extends");
const _devkit = require("@nx/devkit");
const _vite = require("vite");
const _optionsutils = require("../../utils/options-utils");
const _js = require("@nx/js");
const _fs = require("fs");
const _path = require("path");
const _asynciterable = require("@nx/devkit/src/utils/async-iterable");
const _executorutils = require("../../utils/executor-utils");
async function* viteBuildExecutor(options, context) {
    const projectRoot = context.projectsConfigurations.projects[context.projectName].root;
    (0, _executorutils.createBuildableTsConfig)(projectRoot, options, context);
    const normalizedOptions = normalizeOptions(options);
    const buildConfig = (0, _vite.mergeConfig)((0, _optionsutils.getViteSharedConfig)(normalizedOptions, false, context), {
        build: (0, _optionsutils.getViteBuildOptions)(normalizedOptions, context)
    });
    if (!options.skipTypeCheck) {
        await (0, _executorutils.validateTypes)({
            workspaceRoot: context.root,
            projectRoot: projectRoot,
            tsconfig: (0, _optionsutils.getProjectTsConfigPath)(projectRoot)
        });
    }
    const watcherOrOutput = await runInstance(buildConfig);
    const libraryPackageJson = (0, _path.resolve)(projectRoot, 'package.json');
    const rootPackageJson = (0, _path.resolve)(context.root, 'package.json');
    const distPackageJson = (0, _path.resolve)(normalizedOptions.outputPath, 'package.json');
    // Generate a package.json if option has been set.
    if (options.generatePackageJson) {
        if (context.projectGraph.nodes[context.projectName].type !== 'app') {
            _devkit.logger.warn((0, _devkit.stripIndents)`The project ${context.projectName} is using the 'generatePackageJson' option which is deprecated for library projects. It should only be used for applications.
        For libraries, configure the project to use the '@nx/dependency-checks' ESLint rule instead (https://nx.dev/packages/eslint-plugin/documents/dependency-checks).`);
        }
        const builtPackageJson = (0, _js.createPackageJson)(context.projectName, context.projectGraph, {
            target: context.targetName,
            root: context.root,
            isProduction: !options.includeDevDependenciesInPackageJson
        });
        builtPackageJson.type = 'module';
        (0, _devkit.writeJsonFile)(`${options.outputPath}/package.json`, builtPackageJson);
        const packageManager = (0, _devkit.detectPackageManager)(context.root);
        const lockFile = (0, _js.createLockFile)(builtPackageJson, context.projectGraph, packageManager);
        (0, _fs.writeFileSync)(`${options.outputPath}/${(0, _js.getLockFileName)(packageManager)}`, lockFile, {
            encoding: 'utf-8'
        });
    } else if (!(0, _fs.existsSync)(distPackageJson) && (0, _fs.existsSync)(libraryPackageJson) && rootPackageJson !== libraryPackageJson) {
        await (0, _js.copyAssets)({
            outputPath: normalizedOptions.outputPath,
            assets: [
                {
                    input: projectRoot,
                    output: '.',
                    glob: 'package.json'
                }
            ]
        }, context);
    }
    if ('on' in watcherOrOutput) {
        const iterable = (0, _asynciterable.createAsyncIterable)(({ next })=>{
            let success = true;
            watcherOrOutput.on('event', (event)=>{
                if (event.code === 'START') {
                    success = true;
                } else if (event.code === 'ERROR') {
                    success = false;
                } else if (event.code === 'END') {
                    next({
                        success
                    });
                }
                // result must be closed when present.
                // see https://rollupjs.org/guide/en/#rollupwatch
                if ('result' in event) {
                    event.result.close();
                }
            });
        });
        yield* iterable;
    } else {
        var _watcherOrOutput_, _output_;
        const output = (watcherOrOutput == null ? void 0 : watcherOrOutput['output']) || (watcherOrOutput == null ? void 0 : (_watcherOrOutput_ = watcherOrOutput[0]) == null ? void 0 : _watcherOrOutput_.output);
        const fileName = (output == null ? void 0 : (_output_ = output[0]) == null ? void 0 : _output_.fileName) || 'main.cjs';
        const outfile = (0, _path.resolve)(normalizedOptions.outputPath, fileName);
        yield {
            success: true,
            outfile
        };
    }
}
function runInstance(options) {
    return (0, _vite.build)(_extends._({}, options));
}
function normalizeOptions(options) {
    const normalizedOptions = _extends._({}, options);
    // coerce watch to null or {} to match with Vite's watch config
    if (options.watch === false) {
        normalizedOptions.watch = null;
    } else if (options.watch === true) {
        normalizedOptions.watch = {};
    }
    return normalizedOptions;
}
const _default = viteBuildExecutor;

//# sourceMappingURL=build.impl.js.map