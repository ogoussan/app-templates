"use strict";
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    validateTypes: function() {
        return validateTypes;
    },
    createBuildableTsConfig: function() {
        return createBuildableTsConfig;
    }
});
const _js = require("@nx/js");
const _path = require("path");
const _buildablelibsutils = require("@nx/js/src/utils/buildable-libs-utils");
async function validateTypes(opts) {
    const result = await (0, _js.runTypeCheck)({
        workspaceRoot: opts.workspaceRoot,
        tsConfigPath: (0, _path.join)(opts.workspaceRoot, opts.tsconfig),
        mode: 'noEmit'
    });
    await (0, _js.printDiagnostics)(result.errors, result.warnings);
    if (result.errors.length > 0) {
        throw new Error('Found type errors. See above.');
    }
}
function createBuildableTsConfig(projectRoot, options, context) {
    var _options;
    const tsConfig = (0, _path.resolve)(projectRoot, 'tsconfig.json');
    var _buildLibsFromSource;
    (_buildLibsFromSource = (_options = options).buildLibsFromSource) != null ? _buildLibsFromSource : _options.buildLibsFromSource = true;
    if (!options.buildLibsFromSource) {
        const { dependencies } = (0, _buildablelibsutils.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, context.projectName, // When using incremental building and the serve target is called
        // we need to get the deps for the 'build' target instead.
        context.targetName === 'serve' ? 'build' : context.targetName, context.configurationName);
        // this tsconfig is used via the vite ts paths plugin
        (0, _buildablelibsutils.createTmpTsConfig)(tsConfig, context.root, projectRoot, dependencies);
    }
}

//# sourceMappingURL=executor-utils.js.map