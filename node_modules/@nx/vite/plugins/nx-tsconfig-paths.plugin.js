"use strict";
Object.defineProperty(exports, "nxViteTsPaths", {
    enumerable: true,
    get: function() {
        return nxViteTsPaths;
    }
});
const _devkit = require("@nx/devkit");
const _nodefs = require("node:fs");
const _nodepath = require("node:path");
const _tsconfigpaths = require("tsconfig-paths");
function nxViteTsPaths(options = {}) {
    var _options, _options1;
    let matchTsPathEsm;
    let matchTsPathFallback;
    let tsConfigPathsEsm;
    let tsConfigPathsFallback;
    var _extensions;
    (_extensions = (_options = options).extensions) != null ? _extensions : _options.extensions = [
        '.ts',
        '.tsx',
        '.js',
        '.jsx',
        '.json',
        '.mjs',
        '.cjs'
    ];
    var _mainFields;
    (_mainFields = (_options1 = options).mainFields) != null ? _mainFields : _options1.mainFields = [
        [
            'exports',
            '.',
            'import'
        ],
        'module',
        'main'
    ];
    return {
        name: 'nx-vite-ts-paths',
        configResolved (config) {
            const projectRoot = config.root;
            const projectRootFromWorkspaceRoot = (0, _nodepath.relative)(_devkit.workspaceRoot, projectRoot);
            const foundTsConfigPath = getTsConfig((0, _nodepath.join)(_devkit.workspaceRoot, 'tmp', projectRootFromWorkspaceRoot, 'tsconfig.generated.json'));
            if (!foundTsConfigPath) {
                throw new Error((0, _devkit.stripIndents)`Unable to find a tsconfig in the workspace! 
There should at least be a tsconfig.base.json or tsconfig.json in the root of the workspace ${_devkit.workspaceRoot}`);
            }
            const parsed = (0, _tsconfigpaths.loadConfig)(foundTsConfigPath);
            logIt('first parsed tsconfig: ', parsed);
            if (parsed.resultType === 'failed') {
                throw new Error(`Failed loading tsonfig at ${foundTsConfigPath}`);
            }
            tsConfigPathsEsm = parsed;
            matchTsPathEsm = (0, _tsconfigpaths.createMatchPath)(parsed.absoluteBaseUrl, parsed.paths, options.mainFields);
            const rootLevelTsConfig = getTsConfig((0, _nodepath.join)(_devkit.workspaceRoot, 'tsconfig.base.json'));
            const rootLevelParsed = (0, _tsconfigpaths.loadConfig)(rootLevelTsConfig);
            logIt('fallback parsed tsconfig: ', rootLevelParsed);
            if (rootLevelParsed.resultType === 'success') {
                tsConfigPathsFallback = rootLevelParsed;
                matchTsPathFallback = (0, _tsconfigpaths.createMatchPath)(rootLevelParsed.absoluteBaseUrl, rootLevelParsed.paths, [
                    'main',
                    'module'
                ]);
            }
        },
        resolveId (importPath) {
            let resolvedFile;
            try {
                resolvedFile = matchTsPathEsm(importPath);
            } catch (e) {
                logIt('Using fallback path matching.');
                resolvedFile = matchTsPathFallback == null ? void 0 : matchTsPathFallback(importPath);
            }
            if (!resolvedFile) {
                if (tsConfigPathsEsm || tsConfigPathsFallback) {
                    logIt(`Unable to resolve ${importPath} with tsconfig paths. Using fallback file matching.`);
                    resolvedFile = loadFileFromPaths(tsConfigPathsEsm, importPath) || loadFileFromPaths(tsConfigPathsFallback, importPath);
                } else {
                    logIt(`Unable to resolve ${importPath} with tsconfig paths`);
                }
            }
            logIt(`Resolved ${importPath} to ${resolvedFile}`);
            // Returning null defers to other resolveId functions and eventually the default resolution behavior
            // https://rollupjs.org/plugin-development/#resolveid
            return resolvedFile || null;
        }
    };
    function getTsConfig(preferredTsConfigPath) {
        return [
            (0, _nodepath.resolve)(preferredTsConfigPath),
            (0, _nodepath.resolve)((0, _nodepath.join)(_devkit.workspaceRoot, 'tsconfig.base.json')),
            (0, _nodepath.resolve)((0, _nodepath.join)(_devkit.workspaceRoot, 'tsconfig.json'))
        ].find((tsPath)=>{
            if ((0, _nodefs.existsSync)(tsPath)) {
                logIt('Found tsconfig at', tsPath);
                return tsPath;
            }
        });
    }
    function logIt(...msg) {
        if (process.env.NX_VERBOSE_LOGGING === 'true' || (options == null ? void 0 : options.debug)) {
            console.debug('\n[Nx Vite TsPaths]', ...msg);
        }
    }
    function loadFileFromPaths(tsconfig, importPath) {
        logIt(`Trying to resolve file from config in ${tsconfig.configFileAbsolutePath}`);
        let resolvedFile;
        for(const alias in tsconfig.paths){
            const paths = tsconfig.paths[alias];
            const normalizedImport = alias.replace(/\/\*$/, '');
            if (importPath.startsWith(normalizedImport)) {
                const path = (tsconfig.absoluteBaseUrl, paths[0].replace(/\/\*$/, ''));
                resolvedFile = findFile(importPath.replace(normalizedImport, path));
            }
        }
        return resolvedFile;
    }
    function findFile(path) {
        for (const ext of options.extensions){
            const r = (0, _nodepath.resolve)(path + ext);
            if ((0, _nodefs.existsSync)(r)) {
                return r;
            }
        }
    }
}

//# sourceMappingURL=nx-tsconfig-paths.plugin.js.map